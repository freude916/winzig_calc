# 微算

简单算术表达式的解释器。

仍在开发中。

## 注意

这是一个开发中项目，不保证任何可用性和稳定性。

个人练习项目，不保证任何功能的实现或技术支持。

随意 pr，我巴之不得。

## 食用方法

简单地使用 `winzig_calc.c` 里的 `winzig_ez_main(argc, argv)` 作为一个 repl，启动后直接在其中输入下面允许的表达式语法即可。

或者你可以初始化一个 `WinzigCalc` 对象，使用 `winzig_code` 来解析微算代码。

或者你可以尝试单独使用 分词器、解析器 或 执行器。

## 特性

- [x] 只有一种数据类型：`long double`
- [x] 支持大量运算符
  * 计算：   +, -, *, /, ^ ( 这是 pow )
  * 赋值：   =, +=, -=, *=, /=
  * 逻辑：   &, | ( 返回 0 或 1，没有短路或惰性求值 )
  * 比较：   ==, !=, <, <=, >, >=
- [x] ( ) 控制优先级
- [x] { } 控制块
- [x] if, else, while 语句

## 语法

下面我们使用 EBNF 表示微算的语法。

### 语句

```
<expr>[;]
```
分号是可选的，但是建议加上。和Rust等不同，分号不会将表达式的值丢弃。

### 赋值

```
<Assignment> ::= <name> "=" <expr>
```

给变量赋值。变量名只能是字母和数字的组合，不能以数字开头。

由于只有一种数据类型，所以没设计声明语法。

值通过变量名的哈希来存储在哈希表中，有小概率会发生碰撞。我们事先将哈希表填满了 qnan 且不检查变量未定义，请您自行注意。

### 表达式

```
<term> ::= <variable> | <number>
<expr> ::= <term> | <term> <op> <expr> | (<expr>)
```

注意，我们没有一元运算符。

### 控制流

```
if (<expr:condition>) { <block:body> } 
[else { <block:body> }]
```

只支持了单层 if-else 语句，else 是可选的，没有 else if，您可以自行嵌套。

没有 switch-case 语句。

大括号是可选的，没有大括号时控制体仅包括下一条语句。

### 循环

```
while (<expr:condition>) { <block:body> }
```

只支持了 while 循环，没有 for 循环。

大括号是可选的，没有大括号时控制体仅包括下一条语句。

暂无 break 和 continue 语句。

### 预定义函数

目前没有用户自定义函数。

出于省事，所有的函数都是一元函数，没有多参数函数或空参数函数。请在调用空参数函数的时候随便传一个啥。

库一元函数：`sin`, `cos`, `tan`, `asin`, `acos`, `atan`, `sqrt`, `exp`, `log`, `log10`, `ceil`, `floor`, `round`。（调个库谁不会啊）

我们定义的函数：
- `sign(x)`（符号函数，返回 -1, 0, 1）
- `boolean(x)`（转换为布尔值，返回 0 或 1）
- `print(x)`（打印单个数字并换行，返回打印的字节数）
- `random(_)`（返回 0 到 1 之间的随机数）
- `input(_)`（返回输入的数字，或输入q打断整个程序）。


## 已知问题

1. **解析器** 中的阴间特殊判断。
2. 只支持 1 种数字类型：long double
3. 代码中隐藏着依托 bug。纯史山。
4. REPL 对多行输入的支持不够好。

## 未来计划

这段也是问题分析。

等我闲出屁来就会做了。:)

- [ ] **词法分析器**，枚举标记运算符和关键字，方便 **解析器**。
- [ ] **风格化器**，优化代码风格（提前操作，使分词器只需要切分空格）
- [ ] 声明预收集，优化内存，提高速度，方便检查未定义
- [ ] 改进数据结构，保存变量类型，添加更多类型：布尔，字符串等。
- [ ] 字符串字面量
- [ ] 函数语法
- [ ] 全局 **runner** ，错误处理
- [ ] 数组类型
  1. 数组字面量 [,] 语法和数组访问 [] 语法
  2. 切片，范围和其他迭代器方法
  3. for-in 循环
- [ ] 常量优化
